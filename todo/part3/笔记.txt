3-2 生命周期钩子
Vue的生命周期实际上就是Vue实例的生命周期

如果没有指定Vue实例挂载点，只会执行beforeCreate和created

因为mount就是把组件生成的html内容，挂载到DOM上的一个过程，如果不指定Vue实例挂载点，就不会挂载到节点

数据更新的时候会执行beforeUpdate和updated

组件销毁，会解除掉我们所有的事件监听和watch

beforeCreate
created 这两个生命周期，this.$el都是undefined
beforeMount 是Vue实例的挂载点
mounted 如果有template this.$el会变成template, 没有依旧是挂载点，所以对挂载点的操作应该放在mounted里面进行

** 并且在服务端渲染的时候，beforeMount和mounted不会执行， 因为beforeMount和mounted和DOM有关， 在服务端没有DOM的执行环境，所以不会执行

beforeCreate 不要进行数据相关的操作
created

在实际项目文件中，直接使用.vue文件进行开发的时候， 都是没有template的，因为.vue中的template都经过了vue-loader进行处理, 直接变成了一个render function


template: "<div>{{msg}}</div>"
//实际Vue会转换成下面
render(h) {
  console.log('render function invoked');
  return h('div', {} , this.msg);
},
renderError(h, err) {  //只会在开发环境出现，调试render中的错误5
  return h('div', {}, err.stack)
},
errorCaptured() {
  //捕获错误，子组件也能捕获到，正式环境也能使用
}

3-5 computed和watch

computed 监听某个值依赖的变化

watch 监听到一个数据变化，然后执行某些操作, 很适合使用
在页面进行初始化的时候不会执行，只有在产生变化的时候才会执行函数
watch: {
  firstName: {
    handler(newName) {
      this.fullName = newName
    },
    immediate: true
  }
}
// 这个会在初始化时候也执行一次

watch: {
  firstName(newName) {
    this.fullName = newName
  }
} // 在初始化时候不会执行

watch: {
  obj: {
    handler() {
      console.log('a 变化了')
    },
    immediate: true,
    deep: true //深度监听对象属性的变化，遍历obj里面的每一个属性，然后都加上handler，监听变化
  }
}

watch: {
  'obj.a': {
    handler() {

    },
    immediate: true
  }
}

3-6 Vue指令
v-text
v-html
v-bind:id --> :
v-bind:value --> :value
v-model

3-7



